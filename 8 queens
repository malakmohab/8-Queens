


import numpy  

def initial_pop(pop_size):
    return numpy.random.randint(8,size=(pop_size,8))     

def calc_fitness(population):
    fitness_vals=[]
    for x in population:     
        penalty=0
        for i in range(8):   
            r=x[i]            
            for j in range(8): 
                if i==j:
                    continue
                d= abs(i-j)     
                if x[j] in (r,r-d,r+d):
                    penalty+=1
        fitness_vals.append(penalty)

    return -1 * numpy.array(fitness_vals)  


def Selection(population , fitness_vals):
    probs=fitness_vals.copy()      
    probs+=abs(probs.min())+1        
    probs = probs/probs.sum()    
    N= len(population)
    indices = numpy.arange(N)
    selected_indices=numpy.random.choice(indices,size=N,p=probs)   
    selected_population=population[selected_indices]
    return selected_population


def crossover(parent1 , parent2 , pc):   
    r=numpy.random.random()   
    if r<pc:
        m = numpy.random.randint(1,8)   
        child1=numpy.concatenate([parent1[:m],parent2[m:]])
        child2=numpy.concatenate([parent2[:m],parent1[m:]])
    else:
        child1=parent1.copy()
        child2=parent2.copy()
    return child1,child2    


def mutation(indvidual,pm):  
    r =numpy.random.random()
    if r<pm:
        m=numpy.random.randint(8)  
        indvidual[m]=numpy.random.randint(8)  
    return indvidual


def crossover_mutation(selected_population,pc,pm):   
    N=len(selected_population)
    Matrix=numpy.empty((N,8),dtype=int)     
    for i in range (0,N,2):    
        parent1 = selected_population[i]
        parent2 = selected_population[i+1]
        child1, child2= crossover(parent1,parent2,pc)
        Matrix[i]=child1
        Matrix[i+1]=child2
    for i in range(N):
        mutation(Matrix[i],pm)
    return Matrix

def eightqueens(pop_size,max_generations,pc=0.7,pm=0.01):
    population=initial_pop(pop_size)
    best_fitness_overall=None               

    for i_gen in range (max_generations):
        fitness_vals=calc_fitness(population)         
        best_i=fitness_vals.argmax()    
        best_fitness=fitness_vals[best_i]
        if best_fitness_overall is None or best_fitness> best_fitness_overall:
            best_fitness_overall=best_fitness
            best_solution=population[best_i]
        print(f"gen={i_gen+1:06}  -f ={-best_fitness_overall:03}")           
        if best_fitness==0:
            print('\n Found optimal solution')
            break
        selected_pop=Selection(population,fitness_vals)
        population=crossover_mutation(selected_pop,pc,pm)
        print(best_solution)



eightqueens(pop_size=4,max_generations=10,pc=0.7,pm=0.01)
